{"version":3,"file":"background/index.js","mappings":"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","sources":["webpack://canvaspal/./src/utils/logger.ts","webpack://canvaspal/./src/utils/backgroundAssignmentDetector.ts","webpack://canvaspal/./src/utils/backgroundPriorityCalculator.ts","webpack://canvaspal/./src/background/index.ts"],"sourcesContent":["export enum LogLevel {\n    DEBUG = 0,\n    INFO = 1,\n    WARN = 2,\n    ERROR = 3\n}\n\ninterface LogEntry {\n    timestamp: string;\n    level: LogLevel;\n    message: string;\n    data?: any;\n    stack?: string;\n}\n\nexport class Logger {\n    private static readonly MAX_LOGS = 1000;\n    private static instances: Map<string, Logger> = new Map();\n    private context: string;\n    private currentLevel: LogLevel;\n\n    public constructor(context: string, level: LogLevel = LogLevel.INFO) {\n        this.context = context;\n        this.currentLevel = level;\n        this.cleanOldLogs();\n    }\n\n    public static getInstance(context: string, level: LogLevel = LogLevel.INFO): Logger {\n        const key = `${context}-${level}`;\n        if (!this.instances.has(key)) {\n            this.instances.set(key, new Logger(context, level));\n        }\n        return this.instances.get(key)!;\n    }\n\n    setLevel(level: LogLevel): void {\n        this.currentLevel = level;\n    }\n\n    debug(message: string, data?: any): void {\n        this.log(LogLevel.DEBUG, message, data);\n    }\n\n    info(message: string, data?: any): void {\n        this.log(LogLevel.INFO, message, data);\n    }\n\n    warn(message: string, data?: any): void {\n        this.log(LogLevel.WARN, message, data);\n    }\n\n    error(message: string, data?: any): void {\n        this.log(LogLevel.ERROR, message, data);\n    }\n\n    public async log(level: LogLevel, message: string, ...args: any[]): Promise<void> {\n        if (level >= this.currentLevel) {\n            const timestamp = new Date().toISOString();\n            const prefix = this.getLogPrefix(level);\n            const formattedMessage = `[${timestamp}] ${prefix} [${this.context}] ${message}`;\n\n            if (args.length) {\n                const formattedData = this.formatLogData(args);\n                console.log(formattedMessage, formattedData);\n            } else {\n                console.log(formattedMessage);\n            }\n\n            const entry: LogEntry = {\n                timestamp,\n                level,\n                message,\n                data: args,\n                stack: Error().stack\n            };\n\n            this.saveLogs(entry);\n\n            if (level === LogLevel.ERROR) {\n                this.notifyError(entry);\n            }\n        }\n    }\n\n    private getLogPrefix(level: LogLevel): string {\n        switch (level) {\n            case LogLevel.DEBUG:\n                return 'ðŸ” DEBUG:';\n            case LogLevel.INFO:\n                return 'ðŸ“¢ INFO:';\n            case LogLevel.WARN:\n                return 'âš ï¸ WARN:';\n            case LogLevel.ERROR:\n                return 'âŒ ERROR:';\n            default:\n                return 'ðŸ“¢';\n        }\n    }\n\n    private formatLogData(data: any): any {\n        try {\n            if (Array.isArray(data)) {\n                return data.map(item => this.formatLogData(item));\n            }\n\n            if (data && typeof data === 'object') {\n                // Check if it's an Error object\n                if (data instanceof Error) {\n                    return {\n                        name: data.name,\n                        message: data.message,\n                        stack: data.stack\n                    };\n                }\n\n                // Handle regular objects\n                const formatted: Record<string, any> = {};\n                for (const [key, value] of Object.entries(data)) {\n                    formatted[key] = this.formatLogData(value);\n                }\n                return formatted;\n            }\n\n            return data;\n        } catch (error) {\n            return '[Error formatting log data]';\n        }\n    }\n\n    private async saveLogs(entry: LogEntry): Promise<void> {\n        const { logs = [] } = await chrome.storage.local.get('logs');\n        logs.push(entry);\n\n        if (logs.length > Logger.MAX_LOGS) {\n            logs.splice(0, logs.length - Logger.MAX_LOGS);\n        }\n\n        await chrome.storage.local.set({ logs });\n    }\n\n    private async cleanOldLogs(): Promise<void> {\n        const { logs = [] } = await chrome.storage.local.get('logs');\n        const thirtyDaysAgo = new Date();\n        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n        const filteredLogs = logs.filter((log: LogEntry) => \n            new Date(log.timestamp) > thirtyDaysAgo\n        );\n\n        await chrome.storage.local.set({ logs: filteredLogs });\n    }\n\n    private notifyError(entry: LogEntry): void {\n        chrome.notifications.create({\n            type: 'basic',\n            iconUrl: '/dist/icons/icon128.png',\n            title: 'CanvasPal Error',\n            message: entry.message,\n            priority: 2\n        });\n    }\n\n    async getLogs(level?: LogLevel): Promise<LogEntry[]> {\n        const { logs = [] } = await chrome.storage.local.get('logs');\n        return level ? logs.filter((log: LogEntry) => log.level === level) : logs;\n    }\n}\n\nexport const logger = Logger.getInstance('default');\n","import { Assignment, AssignmentType } from '../types/models';\nimport { Logger } from './logger';\n\nexport class BackgroundAssignmentDetector {\n    private logger: Logger;\n\n    constructor() {\n        this.logger = new Logger('BackgroundAssignmentDetector');\n    }\n\n    public async detectAssignments(): Promise<Assignment[]> {\n        try {\n            // Monitor API fetches in parallel\n            const [plannerItems, missingSubmissions, dashboardItems] = await Promise.all([\n                this.fetchPlannerItems(),\n                this.fetchMissingSubmissions(),\n                this.parseDashboardCards()\n            ]);\n\n            const allAssignments = [...plannerItems, ...missingSubmissions, ...dashboardItems]\n                .filter(assignment => this.isValidAssignment(assignment));\n\n            return allAssignments;\n        } catch (error) {\n            this.logger.error('Error detecting assignments:', error);\n            return [];\n        }\n    }\n\n    private async fetchFromContentScript(url: string, options: RequestInit = {}): Promise<any> {\n        const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n        if (!tabs[0]?.id) {\n            throw new Error('No active tab found');\n        }\n\n        const response = await chrome.tabs.sendMessage(tabs[0].id, {\n            type: 'FETCH_REQUEST',\n            url,\n            options: {\n                ...options,\n                credentials: 'same-origin',\n                headers: {\n                    'Accept': 'application/json',\n                    'X-Requested-With': 'XMLHttpRequest',\n                    ...options.headers\n                }\n            }\n        });\n\n        if (!response.success) {\n            throw new Error(response.error || 'Failed to fetch data');\n        }\n\n        return response.data;\n    }\n\n    private async fetchPlannerItems(): Promise<Assignment[]> {\n        try {\n            const items = await this.fetchFromContentScript('/api/v1/planner/items?per_page=50');\n            return items.map((item: any) => this.convertPlannerItem(item))\n                .filter((item: Assignment | null): item is Assignment => item !== null);\n        } catch (error) {\n            this.logger.error('Error fetching planner items:', error);\n            return [];\n        }\n    }\n\n    private async fetchMissingSubmissions(): Promise<Assignment[]> {\n        try {\n            const submissions = await this.fetchFromContentScript('/api/v1/users/self/missing_submissions?include[]=planner_overrides');\n            return submissions.map((submission: any) => this.convertMissingSubmission(submission))\n                .filter((item: Assignment | null): item is Assignment => item !== null);\n        } catch (error) {\n            this.logger.error('Error fetching missing submissions:', error);\n            return [];\n        }\n    }\n\n    private async parseDashboardCards(): Promise<Assignment[]> {\n        try {\n            const cards = await this.fetchFromContentScript('/api/v1/dashboard/dashboard_cards');\n            const assignments: Assignment[] = [];\n\n            for (const card of cards) {\n                if (card.assignments) {\n                    const processed = card.assignments\n                        .map((assignment: any) => this.convertDashboardAssignment(assignment, card))\n                        .filter((item: Assignment | null): item is Assignment => item !== null);\n                    assignments.push(...processed);\n                }\n            }\n\n            return assignments;\n        } catch (error) {\n            this.logger.error('Error parsing dashboard cards:', error);\n            return [];\n        }\n    }\n\n    private convertPlannerItem(item: any): Assignment | null {\n        if (!item.plannable || !item.plannable_type) return null;\n\n        const type = this.determineAssignmentType(item.plannable_type);\n        const dueDate = item.plannable_date ? new Date(item.plannable_date) : null;\n\n        if (!type || !dueDate) return null;\n\n        return {\n            id: item.plannable_id.toString(),\n            title: item.plannable?.title || item.plannable?.name || '',\n            dueDate,\n            course: item.context_name || '',\n            courseId: item.course_id?.toString(),\n            type,\n            points: item.plannable?.points_possible,\n            maxPoints: item.plannable?.points_possible,\n            completed: !!item.planner_override?.marked_complete,\n            priorityScore: 0,\n            url: item.html_url,\n            details: {\n                submissionType: item.plannable?.submission_types,\n                isCompleted: !!item.planner_override?.marked_complete,\n                isLocked: !!item.plannable?.locked_for_user,\n                description: item.plannable?.description\n            }\n        };\n    }\n\n    private convertMissingSubmission(submission: any): Assignment | null {\n        if (!submission.due_at) return null;\n\n        return {\n            id: submission.id.toString(),\n            title: submission.name || submission.assignment?.name || '',\n            dueDate: new Date(submission.due_at),\n            course: submission.course?.name || '',\n            courseId: submission.course_id?.toString(),\n            type: 'assignment',\n            points: submission.points_possible,\n            maxPoints: submission.points_possible,\n            completed: false,\n            priorityScore: 0,\n            url: submission.html_url,\n            details: {\n                isCompleted: false,\n                isLocked: false\n            }\n        };\n    }\n\n    private convertDashboardAssignment(assignment: any, card: any): Assignment | null {\n        if (!assignment.due_at) return null;\n\n        const type = this.determineAssignmentType(assignment.type);\n        \n        return {\n            id: assignment.id.toString(),\n            title: assignment.name || '',\n            dueDate: new Date(assignment.due_at),\n            course: card.shortName || '',\n            courseId: card.id?.toString(),\n            type,\n            points: assignment.points_possible,\n            maxPoints: assignment.points_possible,\n            completed: !!assignment.has_submitted_submissions,\n            priorityScore: 0,\n            url: assignment.html_url,\n            details: {\n                submissionType: assignment.submission_types,\n                isCompleted: !!assignment.has_submitted_submissions,\n                isLocked: !!assignment.locked_for_user,\n                description: assignment.description\n            }\n        };\n    }\n\n    private determineAssignmentType(type: string): AssignmentType {\n        switch (type.toLowerCase()) {\n            case 'quiz':\n            case 'quizzes/quiz':\n                return 'quiz';\n            case 'discussion_topic':\n                return 'discussion';\n            case 'announcement':\n                return 'announcement';\n            default:\n                return 'assignment';\n        }\n    }\n\n    private isValidAssignment(assignment: Assignment | null): assignment is Assignment {\n        return assignment !== null &&\n            !!assignment.title &&\n            !!assignment.dueDate &&\n            !!assignment.course;\n    }\n}","import { Assignment, PriorityWeights } from '../types/models';\nimport { Logger } from './logger';\n\nexport class BackgroundPriorityCalculator {\n    private readonly PRIORITY_WEIGHTS: PriorityWeights = {\n        GRADE_IMPACT: 0.4,\n        COURSE_GRADE: 0.3,\n        DUE_DATE: 0.3\n    };\n\n    private logger: Logger;\n\n    constructor() {\n        this.logger = new Logger('BackgroundPriorityCalculator');\n    }\n\n    public calculatePriority(assignment: Assignment): number {\n        try {\n            const metrics = {\n                daysUntilDue: this.calculateDaysUntilDue(assignment.dueDate),\n                gradeImpact: this.calculateGradeImpact(assignment),\n                courseGradeImpact: this.calculateCourseGradeImpact(assignment),\n                typeWeight: this.getTypeWeight(assignment.type)\n            };\n\n            // Calculate individual components\n            const components = {\n                gradeComponent: metrics.gradeImpact * this.PRIORITY_WEIGHTS.GRADE_IMPACT,\n                courseComponent: metrics.courseGradeImpact * this.PRIORITY_WEIGHTS.COURSE_GRADE,\n                dateComponent: this.calculateDueDatePriority(metrics.daysUntilDue) * this.PRIORITY_WEIGHTS.DUE_DATE\n            };\n\n            // Calculate final priority\n            const basePriority = components.gradeComponent + components.courseComponent + components.dateComponent;\n            const finalPriority = Math.min(Math.max(basePriority * metrics.typeWeight, 0), 1);\n\n            return finalPriority;\n        } catch (error) {\n            this.logger.error('Error calculating priority:', error);\n            return 0;\n        }\n    }\n\n    private calculateDaysUntilDue(dueDate: Date): number {\n        const now = new Date();\n        const diffTime = dueDate.getTime() - now.getTime();\n        return Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n    }\n\n    private calculateDueDatePriority(daysUntilDue: number): number {\n        if (daysUntilDue <= 0) return 1; // Overdue assignments get highest priority\n        if (daysUntilDue >= 14) return 0.2; // Far future assignments get low priority\n        return 1 - (daysUntilDue / 14); // Linear decrease in priority over 14 days\n    }\n\n    private calculateGradeImpact(assignment: Assignment): number {\n        if (!assignment.points || !assignment.maxPoints) return 0.5; // Default impact if no points info\n        return Math.min(assignment.points / 100, 1); // Normalize to 0-1 range\n    }\n\n    private calculateCourseGradeImpact(assignment: Assignment): number {\n        if (!assignment.courseGrade) return 0.85; // Default if no course grade available\n        return 1 - assignment.courseGrade; // Lower grades mean higher priority\n    }\n\n    private getTypeWeight(type: Assignment['type']): number {\n        switch (type) {\n            case 'quiz':\n                return 1.2; // Quizzes get 20% boost\n            case 'assignment':\n                return 1.0; // Standard weight\n            case 'discussion':\n                return 0.8; // Discussions slightly lower\n            case 'announcement':\n                return 0.5; // Announcements lowest priority\n            default:\n                return 1.0;\n        }\n    }\n\n    public setPriorityWeights(weights: Partial<PriorityWeights>): void {\n        const totalWeight = (weights.GRADE_IMPACT || this.PRIORITY_WEIGHTS.GRADE_IMPACT) +\n                          (weights.COURSE_GRADE || this.PRIORITY_WEIGHTS.COURSE_GRADE) +\n                          (weights.DUE_DATE || this.PRIORITY_WEIGHTS.DUE_DATE);\n\n        if (Math.abs(totalWeight - 1) > 0.001) {\n            this.logger.warn('Priority weights do not sum to 1. Using default weights.');\n            return;\n        }\n\n        Object.assign(this.PRIORITY_WEIGHTS, weights);\n        this.logger.info('Priority weights updated:', this.PRIORITY_WEIGHTS);\n    }\n}","import type { CalendarEvent, PrioritySettings, GradeData, DashboardData, Assignment } from '../types/models';\nimport { parseICalFeed } from '../utils/calendar';\nimport { calculatePriority } from '../utils/priorities';\nimport { logger, LogLevel, Logger } from '../utils/logger';\nimport { BackgroundAssignmentDetector } from '../utils/backgroundAssignmentDetector';\nimport { BackgroundPriorityCalculator } from '../utils/backgroundPriorityCalculator';\n\nimport { Settings } from '../types/models';\n\ninterface ICalEvent extends CalendarEvent {\n    gradeWeight?: number;\n    pointsPossible?: number;\n    currentScore?: number;\n}\n\nclass BackgroundService {\n    private static readonly SYNC_INTERVAL = 30 * 60 * 1000;\n    private static readonly RETRY_INTERVAL = 5 * 60 * 1000;\n    private gradeData: { [courseId: string]: GradeData } = {};\n    private dashboardData: { [courseId: string]: DashboardData } = {};\n    private lastSyncTime = 0;\n    private syncIntervalId?: NodeJS.Timeout;\n    private retryTimeoutId?: NodeJS.Timeout;\n    private settings: Settings;\n    private assignments: Assignment[] = [];\n    private detector: BackgroundAssignmentDetector;\n    private priorityCalculator: BackgroundPriorityCalculator;\n    private logger: Logger;\n    private contentScriptReady = false;\n\n    constructor() {\n        this.settings = {\n            priorityWeights: {\n                GRADE_IMPACT: 0.4,\n                COURSE_GRADE: 0.3,\n                DUE_DATE: 0.3\n            },\n            typeWeights: {\n                quiz: 1.2,\n                assignment: 1.0,\n                discussion: 0.8,\n                announcement: 0.5\n            },\n            displayOptions: {\n                showCourseNames: true,\n                showGradeImpact: true,\n                showPriorityScores: true,\n                highlightOverdue: true\n            },\n            refreshInterval: 30,\n            debugSettings: {\n                enabled: false,\n                logLevel: 'info',\n                showDateDebug: false,\n                showAssignmentDebug: false,\n                showPriorityDebug: false\n            },\n            icalUrl: ''\n        };\n        this.detector = new BackgroundAssignmentDetector();\n        this.priorityCalculator = new BackgroundPriorityCalculator();\n        this.logger = new Logger('BackgroundService');\n        this.initialize();\n        this.setupAutoRefresh();\n    }\n\n    public async initialize(): Promise<void> {\n        try {\n            // Load settings from sync storage\n            const { settings } = await chrome.storage.sync.get('settings');\n            if (settings) {\n                this.settings = settings;\n            } else {\n                // Initialize default settings if none exist\n                await chrome.storage.sync.set({ settings: this.settings });\n            }\n\n            // Set up message listeners\n            chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n                this.handleMessage(message, sender, sendResponse);\n                return true; // Keep the message channel open for async response\n            });\n\n            this.startPeriodicSync();\n            this.logger.info('Background service initialized');\n        } catch (error) {\n            this.logger.error('Error initializing background service:', error);\n        }\n    }\n\n    private async handleMessage(\n        message: any,\n        sender: chrome.runtime.MessageSender,\n        sendResponse: (response?: any) => void\n    ): Promise<void> {\n        try {\n            this.logger.debug('Received message:', { type: message.type });\n\n            // Handle CONTENT_SCRIPT_READY first to ensure proper initialization\n            if (message.type === 'CONTENT_SCRIPT_READY') {\n                this.logger.info('Content script ready');\n                this.contentScriptReady = true;\n                sendResponse({ success: true });\n\n                // Initialize debug settings\n                const settings = await chrome.storage.sync.get('settings');\n                if (settings?.settings?.debugSettings) {\n                    await this.handleSettingsUpdate({\n                        ...settings.settings,\n                        debugSettings: {\n                            ...settings.settings.debugSettings,\n                            enabled: true\n                        }\n                    });\n                }\n\n                // Wait a bit for the page to fully load before fetching assignments\n                setTimeout(() => {\n                    void this.refreshAssignments();\n                }, 1000);\n                return;\n            }\n\n            switch (message.type) {\n                case 'SETTINGS_UPDATED':\n                    try {\n                        await this.handleSettingsUpdate(message.settings);\n                        sendResponse({ success: true });\n                    } catch (error: unknown) {\n                        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n                        console.error('Error handling settings update:', errorMessage);\n                        sendResponse({ success: false, error: errorMessage });\n                    }\n                    break;\n\n                case 'GET_ASSIGNMENTS':\n                    try {\n                        if (!this.contentScriptReady) {\n                            sendResponse({ assignments: [], message: 'Loading assignments...' });\n                            return;\n                        }\n                        const assignments = await this.getAssignments();\n                        sendResponse({ assignments });\n                    } catch (error: unknown) {\n                        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n                        console.error('Error getting assignments:', errorMessage);\n                        sendResponse({ success: false, error: errorMessage });\n                    }\n                    break;\n\n                case 'UPDATE_ASSIGNMENT_COMPLETION':\n                    await this.updateAssignmentCompletion(\n                        message.assignmentId,\n                        message.completed\n                    );\n                    sendResponse({ success: true });\n                    break;\n\n                case 'REFRESH_ASSIGNMENTS':\n                    await this.refreshAssignments();\n                    sendResponse({ success: true });\n                    break;\n\n                case 'GRADE_DATA':\n                    this.handleGradeData(message.data);\n                    sendResponse({ success: true });\n                    break;\n\n                case 'DASHBOARD_DATA':\n                    this.handleDashboardData(message.data);\n                    sendResponse({ success: true });\n                    break;\n\n                default:\n                    this.logger.warn('Unknown message type:', message);\n                    sendResponse({ error: 'Unknown message type' });\n            }\n        } catch (error) {\n            this.logger.error('Error handling message:', error);\n            sendResponse({ error: 'Internal error' });\n        }\n    }\n\n    private async handleSettingsUpdate(newSettings: Settings): Promise<void> {\n        try {\n            this.settings = newSettings;\n            \n            // Save to storage\n            await chrome.storage.sync.set({ settings: newSettings });\n            this.logger.info('Settings saved to sync storage');\n\n            // Save to local storage for faster access\n            await chrome.storage.local.set({ settings: newSettings });\n            this.logger.info('Settings saved to local storage');\n\n            // Notify all Canvas tabs\n            const tabs = await chrome.tabs.query({\n                url: [\n                    \"*://*.instructure.com/*\",\n                    \"*://*.canvas.com/*\"\n                ]\n            });\n\n            // Send update to each tab with retry logic\n            const updatePromises = tabs.map(async tab => {\n                if (tab.id) {\n                    try {\n                        await chrome.tabs.sendMessage(tab.id, {\n                            type: 'SETTINGS_UPDATED',\n                            settings: newSettings\n                        });\n                        this.logger.debug(`Settings updated in tab ${tab.id}`);\n                    } catch (error) {\n                        // If tab is not ready, queue update for retry\n                        this.logger.debug(`Could not update tab ${tab.id}, will retry:`, error);\n                        setTimeout(async () => {\n                            try {\n                                if (tab.id) {\n                                    await chrome.tabs.sendMessage(tab.id, {\n                                        type: 'SETTINGS_UPDATED',\n                                        settings: newSettings\n                                    });\n                                    this.logger.debug(`Settings updated in tab ${tab.id} after retry`);\n                                }\n                            } catch (retryError) {\n                                this.logger.debug(`Failed to update tab ${tab.id} after retry:`, retryError);\n                            }\n                        }, 2000); // Retry after 2 seconds\n                    }\n                }\n            });\n\n            await Promise.all(updatePromises);\n            this.logger.info('Settings updated and propagated to all tabs');\n\n            // Trigger a sync with new settings\n            await this.performSync();\n        } catch (error) {\n            this.logger.error('Error in handleSettingsUpdate:', error);\n            throw error;\n        }\n    }\n\n    private async getAssignments(): Promise<Assignment[]> {\n        if (this.assignments.length === 0) {\n            await this.refreshAssignments();\n        }\n        return this.assignments;\n    }\n\n    public async refreshAssignments(): Promise<void> {\n        if (!this.contentScriptReady) {\n            this.logger.warn('Content script not ready, waiting for initialization');\n            return;\n        }\n\n        try {\n            // Find active Canvas tab\n            const tabs = await chrome.tabs.query({\n                active: true,\n                url: [\"*://*.instructure.com/*\", \"*://*.canvas.com/*\"]\n            });\n\n            if (!tabs.length) {\n                this.logger.warn('No active Canvas tab found');\n                this.assignments = [];\n                await this.saveAssignments();\n                this.notifyPopups();\n                return;\n            }\n\n            // Get assignments from detector\n            const newAssignments = await this.detector.detectAssignments();\n\n            // Calculate priorities for each assignment\n            newAssignments.forEach((assignment: Assignment) => {\n                assignment.priorityScore = this.priorityCalculator.calculatePriority(assignment);\n            });\n\n            // Sort by priority\n            newAssignments.sort((a: Assignment, b: Assignment) => b.priorityScore - a.priorityScore);\n\n            // Update stored assignments\n            this.assignments = newAssignments;\n\n            // Save to storage and notify popups\n            await this.saveAssignments();\n            this.notifyPopups();\n\n            this.logger.info('Assignments refreshed:', {\n                count: newAssignments.length,\n                types: this.getAssignmentTypeCounts(newAssignments)\n            });\n        } catch (error) {\n            this.logger.error('Error refreshing assignments:', error);\n            this.assignments = [];\n            await this.saveAssignments();\n            this.notifyPopups();\n            throw error;\n        }\n    }\n\n    public async updateAssignmentCompletion(\n        assignmentId: string,\n        completed: boolean\n    ): Promise<void> {\n        const assignment = this.assignments.find(a => a.id === assignmentId);\n        if (assignment) {\n            assignment.completed = completed;\n            await this.saveAssignments();\n            this.notifyPopups();\n        }\n    }\n\n    private async saveAssignments(): Promise<void> {\n        try {\n            await chrome.storage.local.set({ \n                assignments: this.assignments,\n                lastUpdated: new Date().toISOString()\n            });\n        } catch (error) {\n            this.logger.error('Error saving assignments:', error);\n            throw error;\n        }\n    }\n\n    private notifyPopups(): void {\n        const message = {\n            type: 'ASSIGNMENTS_UPDATED',\n            assignments: this.assignments,\n            status: this.getAssignmentStatus()\n        };\n\n        // Send to popups\n        chrome.runtime.sendMessage(message).catch(error => {\n            // Ignore errors - popups might not be open\n            this.logger.debug('No popups to notify:', error);\n        });\n\n        // Send to content scripts\n        chrome.tabs.query({\n            url: [\"*://*.instructure.com/*\", \"*://*.canvas.com/*\"]\n        }).then(tabs => {\n            tabs.forEach(tab => {\n                if (tab.id) {\n                    chrome.tabs.sendMessage(tab.id, message).catch(error => {\n                        this.logger.debug(`Could not notify tab ${tab.id}:`, error);\n                    });\n                }\n            });\n        });\n    }\n\n    private getAssignmentStatus(): string {\n        if (!this.contentScriptReady) {\n            return 'Loading assignments...';\n        }\n        if (this.assignments.length === 0) {\n            return 'No assignments found';\n        }\n        return `Found ${this.assignments.length} assignments`;\n    }\n\n    private setupAutoRefresh(): void {\n        // Refresh every 30 minutes\n        chrome.alarms.create('refreshAssignments', { periodInMinutes: 30 });\n        \n        chrome.alarms.onAlarm.addListener(async (alarm) => {\n            if (alarm.name === 'refreshAssignments') {\n                await this.refreshAssignments();\n            }\n        });\n    }\n\n    private getAssignmentTypeCounts(assignments: Assignment[]): Record<string, number> {\n        return assignments.reduce((counts, assignment) => {\n            counts[assignment.type] = (counts[assignment.type] || 0) + 1;\n            return counts;\n        }, {} as Record<string, number>);\n    }\n\n    private handleGradeData(data: GradeData): void {\n        try {\n            this.logger.info('Received grade data:', data);\n            this.gradeData[data.courseName] = data;\n            chrome.storage.local.set({ \n                [`grades_${data.courseName}`]: data,\n                lastUpdated: new Date().toISOString()\n            });\n        } catch (error) {\n            this.logger.error('Error handling grade data:', error);\n        }\n    }\n\n    private handleDashboardData(data: DashboardData[]): void {\n        try {\n            this.logger.info('Received dashboard data:', data);\n            data.forEach(courseData => {\n                this.dashboardData[courseData.courseName] = courseData;\n                chrome.storage.local.set({\n                    [`dashboard_${courseData.courseName}`]: courseData,\n                    lastUpdated: new Date().toISOString()\n                });\n            });\n            \n            // Update assignments with dashboard data\n            this.mergeDashboardData();\n        } catch (error) {\n            this.logger.error('Error handling dashboard data:', error);\n        }\n    }\n\n    private mergeDashboardData(): void {\n        // Update existing assignments with dashboard information\n        this.assignments = this.assignments.map(assignment => {\n            const dashboardAssignment = this.findDashboardAssignment(assignment);\n            if (dashboardAssignment) {\n                return {\n                    ...assignment,\n                    dueDate: new Date(dashboardAssignment.dueDate),\n                    type: dashboardAssignment.type || assignment.type\n                };\n            }\n            return assignment;\n        });\n\n        // Add new assignments from dashboard that don't exist\n        Object.values(this.dashboardData).forEach(courseData => {\n            courseData.assignments.forEach(dashboardAssignment => {\n                const exists = this.assignments.some(a => \n                    a.title.toLowerCase() === dashboardAssignment.name.toLowerCase() &&\n                    a.course === courseData.courseName\n                );\n\n                if (!exists) {\n                    const newAssignment: Assignment = {\n                        id: `${courseData.courseName}_${dashboardAssignment.name}`,\n                        title: dashboardAssignment.name,\n                        dueDate: new Date(dashboardAssignment.dueDate),\n                        course: courseData.courseName,\n                        courseId: courseData.courseName,\n                        type: dashboardAssignment.type,\n                        points: 0,\n                        maxPoints: 0,\n                        priorityScore: 0,\n                        completed: false,\n                        url: '',\n                        details: {\n                            isCompleted: false,\n                            isLocked: false\n                        }\n                    };\n                    this.assignments.push(newAssignment);\n                }\n            });\n        });\n\n        // Recalculate priorities and sort\n        this.assignments.forEach(assignment => {\n            assignment.priorityScore = this.priorityCalculator.calculatePriority(assignment);\n        });\n        this.assignments.sort((a, b) => b.priorityScore - a.priorityScore);\n\n        // Save updated assignments\n        void this.saveAssignments();\n    }\n\n    private findDashboardAssignment(assignment: Assignment): DashboardData['assignments'][0] | undefined {\n        const courseData = this.dashboardData[assignment.course];\n        if (!courseData) return undefined;\n\n        return courseData.assignments.find(a => \n            a.name.toLowerCase() === assignment.title.toLowerCase()\n        );\n    }\n\n    private startPeriodicSync(): void {\n        if (this.syncIntervalId) {\n            clearInterval(this.syncIntervalId);\n            this.syncIntervalId = undefined;\n        }\n        if (this.retryTimeoutId) {\n            clearTimeout(this.retryTimeoutId);\n            this.retryTimeoutId = undefined;\n        }\n\n        void this.performSync();\n        const intervalId = setInterval(\n            () => { void this.performSync(); },\n            BackgroundService.SYNC_INTERVAL\n        );\n        this.syncIntervalId = intervalId;\n    }\n\n    public async performSync(): Promise<void> {\n        try {\n            const now = Date.now();\n            if (now - this.lastSyncTime < 60000) {\n                return;\n            }\n\n            await this.refreshAssignments();\n            this.lastSyncTime = now;\n            await this.logger.info('Sync completed successfully');\n            chrome.runtime.sendMessage({ type: \"syncComplete\", timestamp: now });\n        } catch (error) {\n            await this.logger.error('Sync failed', error);\n            console.error(\"Sync failed:\", error);\n            const timeoutId = setTimeout(() => {\n                void this.performSync();\n            }, BackgroundService.RETRY_INTERVAL);\n            this.retryTimeoutId = timeoutId;\n            chrome.runtime.sendMessage({ \n                type: \"syncError\", \n                error: error instanceof Error ? error.message : \"Unknown error\"\n            });\n        }\n    }\n}\n\n// Create and export a singleton instance\nexport const backgroundService = new BackgroundService();\n\n// Set up global message listener first\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    // Handle PING immediately\n    if (message.type === 'PING') {\n        sendResponse({ success: true });\n        return true;\n    }\n    return false;\n});\n\n// Initialize background service\n(async () => {\n    try {\n        // Initialize core service\n        await backgroundService.initialize();\n        console.log('Background service initialized');\n\n        // Set up alarm listener for periodic sync\n        chrome.alarms.create('sync', { periodInMinutes: 30 });\n        chrome.alarms.onAlarm.addListener((alarm) => {\n            if (alarm.name === 'sync') {\n                void backgroundService.performSync();\n            }\n        });\n\n        // Add keyboard command listener\n        chrome.commands.onCommand.addListener((command) => {\n            if (command === 'refresh-assignments') {\n                void backgroundService.performSync();\n            }\n        });\n\n        console.log('Background service setup complete');\n    } catch (error: unknown) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n        console.error('Failed to initialize background service:', errorMessage);\n        throw error;\n    }\n})().catch(error => {\n    console.error('Critical error during background service initialization:', error);\n});\n"],"names":["LogLevel","Logger","context","level","INFO","this","currentLevel","cleanOldLogs","getInstance","key","instances","has","set","get","setLevel","debug","message","data","log","DEBUG","info","warn","WARN","error","ERROR","args","timestamp","Date","toISOString","formattedMessage","getLogPrefix","length","formattedData","formatLogData","console","entry","stack","Error","saveLogs","notifyError","Array","isArray","map","item","name","formatted","value","Object","entries","logs","chrome","storage","local","push","MAX_LOGS","splice","thirtyDaysAgo","setDate","getDate","filteredLogs","filter","notifications","create","type","iconUrl","title","priority","getLogs","Map","BackgroundAssignmentDetector","constructor","logger","detectAssignments","plannerItems","missingSubmissions","dashboardItems","Promise","all","fetchPlannerItems","fetchMissingSubmissions","parseDashboardCards","assignment","isValidAssignment","fetchFromContentScript","url","options","tabs","query","active","currentWindow","id","response","sendMessage","credentials","headers","success","convertPlannerItem","submission","convertMissingSubmission","cards","assignments","card","processed","convertDashboardAssignment","plannable","plannable_type","determineAssignmentType","dueDate","plannable_date","plannable_id","toString","course","context_name","courseId","course_id","points","points_possible","maxPoints","completed","planner_override","marked_complete","priorityScore","html_url","details","submissionType","submission_types","isCompleted","isLocked","locked_for_user","description","due_at","shortName","has_submitted_submissions","toLowerCase","BackgroundPriorityCalculator","PRIORITY_WEIGHTS","GRADE_IMPACT","COURSE_GRADE","DUE_DATE","calculatePriority","metrics","daysUntilDue","calculateDaysUntilDue","gradeImpact","calculateGradeImpact","courseGradeImpact","calculateCourseGradeImpact","typeWeight","getTypeWeight","components","gradeComponent","courseComponent","dateComponent","calculateDueDatePriority","basePriority","Math","min","max","now","diffTime","getTime","ceil","courseGrade","setPriorityWeights","weights","totalWeight","abs","assign","BackgroundService","gradeData","dashboardData","lastSyncTime","contentScriptReady","settings","priorityWeights","typeWeights","quiz","discussion","announcement","displayOptions","showCourseNames","showGradeImpact","showPriorityScores","highlightOverdue","refreshInterval","debugSettings","enabled","logLevel","showDateDebug","showAssignmentDebug","showPriorityDebug","icalUrl","detector","priorityCalculator","initialize","setupAutoRefresh","sync","runtime","onMessage","addListener","sender","sendResponse","handleMessage","startPeriodicSync","handleSettingsUpdate","setTimeout","refreshAssignments","errorMessage","getAssignments","updateAssignmentCompletion","assignmentId","handleGradeData","handleDashboardData","newSettings","updatePromises","async","tab","retryError","performSync","saveAssignments","notifyPopups","newAssignments","forEach","sort","a","b","count","types","getAssignmentTypeCounts","find","lastUpdated","status","getAssignmentStatus","catch","then","alarms","periodInMinutes","onAlarm","alarm","reduce","counts","courseName","courseData","mergeDashboardData","dashboardAssignment","findDashboardAssignment","values","some","newAssignment","syncIntervalId","clearInterval","undefined","retryTimeoutId","clearTimeout","intervalId","setInterval","SYNC_INTERVAL","timeoutId","RETRY_INTERVAL","backgroundService","commands","onCommand","command"],"sourceRoot":""}