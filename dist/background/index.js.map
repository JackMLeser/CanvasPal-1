{"version":3,"file":"background/index.js","mappings":"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","sources":["webpack://canvaspal/./src/utils/logger.ts","webpack://canvaspal/./src/utils/backgroundAssignmentDetector.ts","webpack://canvaspal/./src/utils/backgroundPriorityCalculator.ts","webpack://canvaspal/./src/background/index.ts","webpack://canvaspal/webpack/bootstrap","webpack://canvaspal/webpack/startup"],"sourcesContent":["export enum LogLevel {\n    DEBUG = 0,\n    INFO = 1,\n    WARN = 2,\n    ERROR = 3\n}\n\ninterface LogEntry {\n    timestamp: string;\n    level: LogLevel;\n    message: string;\n    data?: any;\n    stack?: string;\n}\n\nexport class Logger {\n    private static readonly MAX_LOGS = 1000;\n    private static instances: Map<string, Logger> = new Map();\n    private context: string;\n    private currentLevel: LogLevel;\n\n    public constructor(context: string, level: LogLevel = LogLevel.INFO) {\n        this.context = context;\n        this.currentLevel = level;\n        this.cleanOldLogs();\n    }\n\n    public static getInstance(context: string, level: LogLevel = LogLevel.INFO): Logger {\n        const key = `${context}-${level}`;\n        if (!this.instances.has(key)) {\n            this.instances.set(key, new Logger(context, level));\n        }\n        return this.instances.get(key)!;\n    }\n\n    setLevel(level: LogLevel): void {\n        this.currentLevel = level;\n    }\n\n    debug(message: string, data?: any): void {\n        this.log(LogLevel.DEBUG, message, data);\n    }\n\n    info(message: string, data?: any): void {\n        this.log(LogLevel.INFO, message, data);\n    }\n\n    warn(message: string, data?: any): void {\n        this.log(LogLevel.WARN, message, data);\n    }\n\n    error(message: string, data?: any): void {\n        this.log(LogLevel.ERROR, message, data);\n    }\n\n    public async log(level: LogLevel, message: string, ...args: any[]): Promise<void> {\n        if (level >= this.currentLevel) {\n            const timestamp = new Date().toISOString();\n            const prefix = this.getLogPrefix(level);\n            const formattedMessage = `[${timestamp}] ${prefix} [${this.context}] ${message}`;\n\n            if (args.length) {\n                const formattedData = this.formatLogData(args);\n                console.log(formattedMessage, formattedData);\n            } else {\n                console.log(formattedMessage);\n            }\n\n            const entry: LogEntry = {\n                timestamp,\n                level,\n                message,\n                data: args,\n                stack: Error().stack\n            };\n\n            this.saveLogs(entry);\n\n            if (level === LogLevel.ERROR) {\n                this.notifyError(entry);\n            }\n        }\n    }\n\n    private getLogPrefix(level: LogLevel): string {\n        switch (level) {\n            case LogLevel.DEBUG:\n                return 'ðŸ” DEBUG:';\n            case LogLevel.INFO:\n                return 'ðŸ“¢ INFO:';\n            case LogLevel.WARN:\n                return 'âš ï¸ WARN:';\n            case LogLevel.ERROR:\n                return 'âŒ ERROR:';\n            default:\n                return 'ðŸ“¢';\n        }\n    }\n\n    private formatLogData(data: any): any {\n        if (data instanceof Element) {\n            return {\n                tagName: data.tagName,\n                id: data.id,\n                className: data.className,\n                textContent: data.textContent?.substring(0, 100) + '...',\n                html: data.outerHTML?.substring(0, 200) + '...'\n            };\n        }\n\n        if (Array.isArray(data)) {\n            return data.map(item => this.formatLogData(item));\n        }\n\n        if (data && typeof data === 'object') {\n            const formatted: Record<string, any> = {};\n            for (const [key, value] of Object.entries(data)) {\n                formatted[key] = this.formatLogData(value);\n            }\n            return formatted;\n        }\n\n        return data;\n    }\n\n    private async saveLogs(entry: LogEntry): Promise<void> {\n        const { logs = [] } = await chrome.storage.local.get('logs');\n        logs.push(entry);\n\n        if (logs.length > Logger.MAX_LOGS) {\n            logs.splice(0, logs.length - Logger.MAX_LOGS);\n        }\n\n        await chrome.storage.local.set({ logs });\n    }\n\n    private async cleanOldLogs(): Promise<void> {\n        const { logs = [] } = await chrome.storage.local.get('logs');\n        const thirtyDaysAgo = new Date();\n        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n        const filteredLogs = logs.filter((log: LogEntry) => \n            new Date(log.timestamp) > thirtyDaysAgo\n        );\n\n        await chrome.storage.local.set({ logs: filteredLogs });\n    }\n\n    private notifyError(entry: LogEntry): void {\n        chrome.notifications.create({\n            type: 'basic',\n            iconUrl: 'icons/icon128.png',\n            title: 'CanvasPal Error',\n            message: entry.message,\n            priority: 2\n        });\n    }\n\n    async getLogs(level?: LogLevel): Promise<LogEntry[]> {\n        const { logs = [] } = await chrome.storage.local.get('logs');\n        return level ? logs.filter((log: LogEntry) => log.level === level) : logs;\n    }\n}\n\nexport const logger = Logger.getInstance('default');\n","import { Assignment, AssignmentType } from '../types/models';\nimport { Logger } from './logger';\n\nexport class BackgroundAssignmentDetector {\n    private logger: Logger;\n\n    constructor() {\n        this.logger = new Logger('BackgroundAssignmentDetector');\n    }\n\n    public async detectAssignments(): Promise<Assignment[]> {\n        try {\n            // Monitor API fetches in parallel\n            const [plannerItems, missingSubmissions, dashboardItems] = await Promise.all([\n                this.fetchPlannerItems(),\n                this.fetchMissingSubmissions(),\n                this.parseDashboardCards()\n            ]);\n\n            const allAssignments = [...plannerItems, ...missingSubmissions, ...dashboardItems]\n                .filter(assignment => this.isValidAssignment(assignment));\n\n            return allAssignments;\n        } catch (error) {\n            this.logger.error('Error detecting assignments:', error);\n            return [];\n        }\n    }\n\n    private async fetchPlannerItems(): Promise<Assignment[]> {\n        try {\n            const response = await fetch('/api/v1/planner/items?per_page=50', {\n                headers: {\n                    'Accept': 'application/json+canvas-string-ids, application/json',\n                    'X-Requested-With': 'XMLHttpRequest'\n                },\n                credentials: 'same-origin'\n            });\n\n            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n            \n            const items = await response.json();\n            return items.map((item: any) => this.convertPlannerItem(item))\n                .filter((item: Assignment | null): item is Assignment => item !== null);\n        } catch (error) {\n            this.logger.error('Error fetching planner items:', error);\n            return [];\n        }\n    }\n\n    private async fetchMissingSubmissions(): Promise<Assignment[]> {\n        try {\n            const response = await fetch('/api/v1/users/self/missing_submissions?include[]=planner_overrides', {\n                headers: {\n                    'Accept': 'application/json',\n                    'X-Requested-With': 'XMLHttpRequest'\n                },\n                credentials: 'same-origin'\n            });\n\n            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n            \n            const submissions = await response.json();\n            return submissions.map((submission: any) => this.convertMissingSubmission(submission))\n                .filter((item: Assignment | null): item is Assignment => item !== null);\n        } catch (error) {\n            this.logger.error('Error fetching missing submissions:', error);\n            return [];\n        }\n    }\n\n    private async parseDashboardCards(): Promise<Assignment[]> {\n        try {\n            const response = await fetch('/api/v1/dashboard/dashboard_cards', {\n                headers: {\n                    'Accept': 'application/json+canvas-string-ids, application/json',\n                    'X-Requested-With': 'XMLHttpRequest'\n                },\n                credentials: 'same-origin'\n            });\n\n            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n            \n            const cards = await response.json();\n            const assignments: Assignment[] = [];\n\n            for (const card of cards) {\n                if (card.assignments) {\n                    const processed = card.assignments\n                        .map((assignment: any) => this.convertDashboardAssignment(assignment, card))\n                        .filter((item: Assignment | null): item is Assignment => item !== null);\n                    assignments.push(...processed);\n                }\n            }\n\n            return assignments;\n        } catch (error) {\n            this.logger.error('Error parsing dashboard cards:', error);\n            return [];\n        }\n    }\n\n    private convertPlannerItem(item: any): Assignment | null {\n        if (!item.plannable || !item.plannable_type) return null;\n\n        const type = this.determineAssignmentType(item.plannable_type);\n        const dueDate = item.plannable_date ? new Date(item.plannable_date) : null;\n\n        if (!type || !dueDate) return null;\n\n        return {\n            id: item.plannable_id.toString(),\n            title: item.plannable?.title || item.plannable?.name || '',\n            dueDate,\n            course: item.context_name || '',\n            courseId: item.course_id?.toString(),\n            type,\n            points: item.plannable?.points_possible,\n            maxPoints: item.plannable?.points_possible,\n            completed: !!item.planner_override?.marked_complete,\n            priorityScore: 0,\n            url: item.html_url,\n            details: {\n                submissionType: item.plannable?.submission_types,\n                isCompleted: !!item.planner_override?.marked_complete,\n                isLocked: !!item.plannable?.locked_for_user,\n                description: item.plannable?.description\n            }\n        };\n    }\n\n    private convertMissingSubmission(submission: any): Assignment | null {\n        if (!submission.due_at) return null;\n\n        return {\n            id: submission.id.toString(),\n            title: submission.name || submission.assignment?.name || '',\n            dueDate: new Date(submission.due_at),\n            course: submission.course?.name || '',\n            courseId: submission.course_id?.toString(),\n            type: 'assignment',\n            points: submission.points_possible,\n            maxPoints: submission.points_possible,\n            completed: false,\n            priorityScore: 0,\n            url: submission.html_url,\n            details: {\n                isCompleted: false,\n                isLocked: false\n            }\n        };\n    }\n\n    private convertDashboardAssignment(assignment: any, card: any): Assignment | null {\n        if (!assignment.due_at) return null;\n\n        const type = this.determineAssignmentType(assignment.type);\n        \n        return {\n            id: assignment.id.toString(),\n            title: assignment.name || '',\n            dueDate: new Date(assignment.due_at),\n            course: card.shortName || '',\n            courseId: card.id?.toString(),\n            type,\n            points: assignment.points_possible,\n            maxPoints: assignment.points_possible,\n            completed: !!assignment.has_submitted_submissions,\n            priorityScore: 0,\n            url: assignment.html_url,\n            details: {\n                submissionType: assignment.submission_types,\n                isCompleted: !!assignment.has_submitted_submissions,\n                isLocked: !!assignment.locked_for_user,\n                description: assignment.description\n            }\n        };\n    }\n\n    private determineAssignmentType(type: string): AssignmentType {\n        switch (type.toLowerCase()) {\n            case 'quiz':\n            case 'quizzes/quiz':\n                return 'quiz';\n            case 'discussion_topic':\n                return 'discussion';\n            case 'announcement':\n                return 'announcement';\n            default:\n                return 'assignment';\n        }\n    }\n\n    private isValidAssignment(assignment: Assignment | null): assignment is Assignment {\n        return assignment !== null &&\n            !!assignment.title &&\n            !!assignment.dueDate &&\n            !!assignment.course;\n    }\n}","import { Assignment, PriorityWeights } from '../types/models';\nimport { Logger } from './logger';\n\nexport class BackgroundPriorityCalculator {\n    private readonly PRIORITY_WEIGHTS: PriorityWeights = {\n        GRADE_IMPACT: 0.4,\n        COURSE_GRADE: 0.3,\n        DUE_DATE: 0.3\n    };\n\n    private logger: Logger;\n\n    constructor() {\n        this.logger = new Logger('BackgroundPriorityCalculator');\n    }\n\n    public calculatePriority(assignment: Assignment): number {\n        try {\n            const metrics = {\n                daysUntilDue: this.calculateDaysUntilDue(assignment.dueDate),\n                gradeImpact: this.calculateGradeImpact(assignment),\n                courseGradeImpact: this.calculateCourseGradeImpact(assignment),\n                typeWeight: this.getTypeWeight(assignment.type)\n            };\n\n            // Calculate individual components\n            const components = {\n                gradeComponent: metrics.gradeImpact * this.PRIORITY_WEIGHTS.GRADE_IMPACT,\n                courseComponent: metrics.courseGradeImpact * this.PRIORITY_WEIGHTS.COURSE_GRADE,\n                dateComponent: this.calculateDueDatePriority(metrics.daysUntilDue) * this.PRIORITY_WEIGHTS.DUE_DATE\n            };\n\n            // Calculate final priority\n            const basePriority = components.gradeComponent + components.courseComponent + components.dateComponent;\n            const finalPriority = Math.min(Math.max(basePriority * metrics.typeWeight, 0), 1);\n\n            return finalPriority;\n        } catch (error) {\n            this.logger.error('Error calculating priority:', error);\n            return 0;\n        }\n    }\n\n    private calculateDaysUntilDue(dueDate: Date): number {\n        const now = new Date();\n        const diffTime = dueDate.getTime() - now.getTime();\n        return Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n    }\n\n    private calculateDueDatePriority(daysUntilDue: number): number {\n        if (daysUntilDue <= 0) return 1; // Overdue assignments get highest priority\n        if (daysUntilDue >= 14) return 0.2; // Far future assignments get low priority\n        return 1 - (daysUntilDue / 14); // Linear decrease in priority over 14 days\n    }\n\n    private calculateGradeImpact(assignment: Assignment): number {\n        if (!assignment.points || !assignment.maxPoints) return 0.5; // Default impact if no points info\n        return Math.min(assignment.points / 100, 1); // Normalize to 0-1 range\n    }\n\n    private calculateCourseGradeImpact(assignment: Assignment): number {\n        if (!assignment.courseGrade) return 0.85; // Default if no course grade available\n        return 1 - assignment.courseGrade; // Lower grades mean higher priority\n    }\n\n    private getTypeWeight(type: Assignment['type']): number {\n        switch (type) {\n            case 'quiz':\n                return 1.2; // Quizzes get 20% boost\n            case 'assignment':\n                return 1.0; // Standard weight\n            case 'discussion':\n                return 0.8; // Discussions slightly lower\n            case 'announcement':\n                return 0.5; // Announcements lowest priority\n            default:\n                return 1.0;\n        }\n    }\n\n    public setPriorityWeights(weights: Partial<PriorityWeights>): void {\n        const totalWeight = (weights.GRADE_IMPACT || this.PRIORITY_WEIGHTS.GRADE_IMPACT) +\n                          (weights.COURSE_GRADE || this.PRIORITY_WEIGHTS.COURSE_GRADE) +\n                          (weights.DUE_DATE || this.PRIORITY_WEIGHTS.DUE_DATE);\n\n        if (Math.abs(totalWeight - 1) > 0.001) {\n            this.logger.warn('Priority weights do not sum to 1. Using default weights.');\n            return;\n        }\n\n        Object.assign(this.PRIORITY_WEIGHTS, weights);\n        this.logger.info('Priority weights updated:', this.PRIORITY_WEIGHTS);\n    }\n}","import type { CalendarEvent, PrioritySettings, GradeData, DashboardData, Assignment } from '../types/models';\nimport { parseICalFeed } from '../utils/calendar';\nimport { calculatePriority } from '../utils/priorities';\nimport { logger, LogLevel, Logger } from '../utils/logger';\nimport { BackgroundAssignmentDetector } from '../utils/backgroundAssignmentDetector';\nimport { BackgroundPriorityCalculator } from '../utils/backgroundPriorityCalculator';\n\nimport { Settings } from '../types/models';\n\ninterface ICalEvent extends CalendarEvent {\n    gradeWeight?: number;\n    pointsPossible?: number;\n    currentScore?: number;\n}\n\nclass BackgroundService {\n    private static readonly SYNC_INTERVAL = 30 * 60 * 1000;\n    private static readonly RETRY_INTERVAL = 5 * 60 * 1000;\n    private gradeData: { [courseId: string]: GradeData } = {};\n    private dashboardData: { [courseId: string]: DashboardData } = {};\n    private lastSyncTime = 0;\n    private syncIntervalId?: number;\n    private retryTimeoutId?: number;\n    private settings: Settings;\n    private assignments: Assignment[] = [];\n    private detector: BackgroundAssignmentDetector;\n    private priorityCalculator: BackgroundPriorityCalculator;\n    private logger: Logger;\n\n    constructor() {\n        this.settings = {\n            priorityWeights: {\n                GRADE_IMPACT: 0.4,\n                COURSE_GRADE: 0.3,\n                DUE_DATE: 0.3\n            },\n            typeWeights: {\n                quiz: 1.2,\n                assignment: 1.0,\n                discussion: 0.8,\n                announcement: 0.5\n            },\n            displayOptions: {\n                showCourseNames: true,\n                showGradeImpact: true,\n                showPriorityScores: true,\n                highlightOverdue: true\n            },\n            refreshInterval: 30,\n            debugSettings: {\n                enabled: false,\n                logLevel: 'info',\n                showDateDebug: false,\n                showAssignmentDebug: false,\n                showPriorityDebug: false\n            },\n            icalUrl: ''\n        };\n        this.detector = new BackgroundAssignmentDetector();\n        this.priorityCalculator = new BackgroundPriorityCalculator();\n        this.logger = new Logger('BackgroundService');\n        this.initialize();\n        this.setupAutoRefresh();\n    }\n\n    public async initialize(): Promise<void> {\n        try {\n            // Load settings from sync storage\n            const { settings } = await chrome.storage.sync.get('settings');\n            if (settings) {\n                this.settings = settings;\n            } else {\n                // Initialize default settings if none exist\n                await chrome.storage.sync.set({ settings: this.settings });\n            }\n\n            // Set up message listeners\n            chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n                this.handleMessage(message, sender, sendResponse);\n                return true; // Keep the message channel open for async response\n            });\n\n            this.startPeriodicSync();\n            this.logger.info('Background service initialized');\n        } catch (error) {\n            this.logger.error('Error initializing background service:', error);\n        }\n    }\n\n    private async handleMessage(\n        message: any, \n        sender: chrome.runtime.MessageSender, \n        sendResponse: (response?: any) => void\n    ): Promise<void> {\n        try {\n            switch (message.type) {\n                case 'SETTINGS_UPDATED':\n                    await this.handleSettingsUpdate(message.settings);\n                    sendResponse({ success: true });\n                    break;\n\n                case 'GET_ASSIGNMENTS':\n                    const assignments = await this.getAssignments();\n                    sendResponse({ assignments });\n                    break;\n\n                case 'UPDATE_ASSIGNMENT_COMPLETION':\n                    await this.updateAssignmentCompletion(\n                        message.assignmentId,\n                        message.completed\n                    );\n                    sendResponse({ success: true });\n                    break;\n\n                case 'REFRESH_ASSIGNMENTS':\n                    await this.refreshAssignments();\n                    sendResponse({ success: true });\n                    break;\n\n                case 'GRADE_DATA':\n                    this.handleGradeData(message.data);\n                    sendResponse({ success: true });\n                    break;\n\n                case 'DASHBOARD_DATA':\n                    this.handleDashboardData(message.data);\n                    sendResponse({ success: true });\n                    break;\n\n                default:\n                    this.logger.warn('Unknown message type:', message);\n                    sendResponse({ error: 'Unknown message type' });\n            }\n        } catch (error) {\n            this.logger.error('Error handling message:', error);\n            sendResponse({ error: 'Internal error' });\n        }\n    }\n\n    private async handleSettingsUpdate(newSettings: Settings): Promise<void> {\n        this.settings = newSettings;\n        \n        // Save to storage\n        await chrome.storage.sync.set({ settings: newSettings });\n\n        // Notify all Canvas tabs\n        const tabs = await chrome.tabs.query({\n            url: [\n                \"*://*.instructure.com/*\",\n                \"*://*.canvas.com/*\"\n            ]\n        });\n\n        // Send update to each tab\n        const updatePromises = tabs.map(tab => {\n            if (tab.id) {\n                return chrome.tabs.sendMessage(tab.id, {\n                    type: 'SETTINGS_UPDATED',\n                    settings: newSettings\n                }).catch(error => {\n                    // Log but don't fail if a tab doesn't have our content script\n                    this.logger.debug(`Could not update tab ${tab.id}:`, error);\n                });\n            }\n        });\n\n        await Promise.all(updatePromises);\n        this.logger.info('Settings updated and propagated to all tabs');\n\n        // Trigger a sync with new settings\n        await this.performSync();\n    }\n\n    private async getAssignments(): Promise<Assignment[]> {\n        if (this.assignments.length === 0) {\n            await this.refreshAssignments();\n        }\n        return this.assignments;\n    }\n\n    public async refreshAssignments(): Promise<void> {\n        try {\n            // Get assignments from detector\n            const newAssignments = await this.detector.detectAssignments();\n\n            // Calculate priorities for each assignment\n            newAssignments.forEach((assignment: Assignment) => {\n                assignment.priorityScore = this.priorityCalculator.calculatePriority(assignment);\n            });\n\n            // Sort by priority\n            newAssignments.sort((a: Assignment, b: Assignment) => b.priorityScore - a.priorityScore);\n\n            // Update stored assignments\n            this.assignments = newAssignments;\n\n            // Save to storage and notify popups\n            await this.saveAssignments();\n            this.notifyPopups();\n\n            this.logger.info('Assignments refreshed:', {\n                count: newAssignments.length,\n                types: this.getAssignmentTypeCounts(newAssignments)\n            });\n        } catch (error) {\n            this.logger.error('Error refreshing assignments:', error);\n            throw error;\n        }\n    }\n\n    public async updateAssignmentCompletion(\n        assignmentId: string,\n        completed: boolean\n    ): Promise<void> {\n        const assignment = this.assignments.find(a => a.id === assignmentId);\n        if (assignment) {\n            assignment.completed = completed;\n            await this.saveAssignments();\n            this.notifyPopups();\n        }\n    }\n\n    private async saveAssignments(): Promise<void> {\n        try {\n            await chrome.storage.local.set({ \n                assignments: this.assignments,\n                lastUpdated: new Date().toISOString()\n            });\n        } catch (error) {\n            this.logger.error('Error saving assignments:', error);\n            throw error;\n        }\n    }\n\n    private notifyPopups(): void {\n        chrome.runtime.sendMessage({ \n            type: 'ASSIGNMENTS_UPDATED',\n            assignments: this.assignments\n        }).catch(error => {\n            // Ignore errors - popups might not be open\n            this.logger.debug('No popups to notify:', error);\n        });\n    }\n\n    private setupAutoRefresh(): void {\n        // Refresh every 30 minutes\n        chrome.alarms.create('refreshAssignments', { periodInMinutes: 30 });\n        \n        chrome.alarms.onAlarm.addListener(async (alarm) => {\n            if (alarm.name === 'refreshAssignments') {\n                await this.refreshAssignments();\n            }\n        });\n    }\n\n    private getAssignmentTypeCounts(assignments: Assignment[]): Record<string, number> {\n        return assignments.reduce((counts, assignment) => {\n            counts[assignment.type] = (counts[assignment.type] || 0) + 1;\n            return counts;\n        }, {} as Record<string, number>);\n    }\n\n    private handleGradeData(data: GradeData): void {\n        try {\n            this.logger.info('Received grade data:', data);\n            this.gradeData[data.courseName] = data;\n            chrome.storage.local.set({ \n                [`grades_${data.courseName}`]: data,\n                lastUpdated: new Date().toISOString()\n            });\n        } catch (error) {\n            this.logger.error('Error handling grade data:', error);\n        }\n    }\n\n    private handleDashboardData(data: DashboardData[]): void {\n        try {\n            this.logger.info('Received dashboard data:', data);\n            data.forEach(courseData => {\n                this.dashboardData[courseData.courseName] = courseData;\n                chrome.storage.local.set({\n                    [`dashboard_${courseData.courseName}`]: courseData,\n                    lastUpdated: new Date().toISOString()\n                });\n            });\n            \n            // Update assignments with dashboard data\n            this.mergeDashboardData();\n        } catch (error) {\n            this.logger.error('Error handling dashboard data:', error);\n        }\n    }\n\n    private mergeDashboardData(): void {\n        // Update existing assignments with dashboard information\n        this.assignments = this.assignments.map(assignment => {\n            const dashboardAssignment = this.findDashboardAssignment(assignment);\n            if (dashboardAssignment) {\n                return {\n                    ...assignment,\n                    dueDate: new Date(dashboardAssignment.dueDate),\n                    type: dashboardAssignment.type || assignment.type\n                };\n            }\n            return assignment;\n        });\n\n        // Add new assignments from dashboard that don't exist\n        Object.values(this.dashboardData).forEach(courseData => {\n            courseData.assignments.forEach(dashboardAssignment => {\n                const exists = this.assignments.some(a => \n                    a.title.toLowerCase() === dashboardAssignment.name.toLowerCase() &&\n                    a.course === courseData.courseName\n                );\n\n                if (!exists) {\n                    const newAssignment: Assignment = {\n                        id: `${courseData.courseName}_${dashboardAssignment.name}`,\n                        title: dashboardAssignment.name,\n                        dueDate: new Date(dashboardAssignment.dueDate),\n                        course: courseData.courseName,\n                        courseId: courseData.courseName,\n                        type: dashboardAssignment.type,\n                        points: 0,\n                        maxPoints: 0,\n                        priorityScore: 0,\n                        completed: false,\n                        url: '',\n                        details: {\n                            isCompleted: false,\n                            isLocked: false\n                        }\n                    };\n                    this.assignments.push(newAssignment);\n                }\n            });\n        });\n\n        // Recalculate priorities and sort\n        this.assignments.forEach(assignment => {\n            assignment.priorityScore = this.priorityCalculator.calculatePriority(assignment);\n        });\n        this.assignments.sort((a, b) => b.priorityScore - a.priorityScore);\n\n        // Save updated assignments\n        void this.saveAssignments();\n    }\n\n    private findDashboardAssignment(assignment: Assignment): DashboardData['assignments'][0] | undefined {\n        const courseData = this.dashboardData[assignment.course];\n        if (!courseData) return undefined;\n\n        return courseData.assignments.find(a => \n            a.name.toLowerCase() === assignment.title.toLowerCase()\n        );\n    }\n\n    private startPeriodicSync(): void {\n        if (this.syncIntervalId) {\n            window.clearInterval(this.syncIntervalId);\n            this.syncIntervalId = undefined;\n        }\n        if (this.retryTimeoutId) {\n            window.clearTimeout(this.retryTimeoutId);\n            this.retryTimeoutId = undefined;\n        }\n\n        void this.performSync();\n        const intervalId = window.setInterval(\n            () => { void this.performSync(); },\n            BackgroundService.SYNC_INTERVAL\n        );\n        this.syncIntervalId = intervalId;\n    }\n\n    public async performSync(): Promise<void> {\n        try {\n            const now = Date.now();\n            if (now - this.lastSyncTime < 60000) {\n                return;\n            }\n\n            await this.refreshAssignments();\n            this.lastSyncTime = now;\n            await this.logger.info('Sync completed successfully');\n            chrome.runtime.sendMessage({ type: \"syncComplete\", timestamp: now });\n        } catch (error) {\n            await this.logger.error('Sync failed', error);\n            console.error(\"Sync failed:\", error);\n            const timeoutId = window.setTimeout(() => {\n                void this.performSync();\n            }, BackgroundService.RETRY_INTERVAL);\n            this.retryTimeoutId = timeoutId;\n            chrome.runtime.sendMessage({ \n                type: \"syncError\", \n                error: error instanceof Error ? error.message : \"Unknown error\"\n            });\n        }\n    }\n}\n\n// Create and export a singleton instance\nexport const backgroundService = new BackgroundService();\n\n// Initialize background service and set up listeners\nbackgroundService.initialize().then(() => {\n    // Set up alarm listener for periodic sync\n    chrome.alarms.create('sync', { periodInMinutes: 30 });\n    chrome.alarms.onAlarm.addListener((alarm) => {\n        if (alarm.name === 'sync') {\n            void backgroundService.performSync();\n        }\n    });\n\n    // Add keyboard command listener\n    chrome.commands.onCommand.addListener((command) => {\n        if (command === 'refresh-assignments') {\n            void backgroundService.performSync();\n        }\n    });\n});\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(922);\n"],"names":["LogLevel","Logger","context","level","INFO","this","currentLevel","cleanOldLogs","getInstance","key","instances","has","set","get","setLevel","debug","message","data","log","DEBUG","info","warn","WARN","error","ERROR","args","timestamp","Date","toISOString","formattedMessage","getLogPrefix","length","formattedData","formatLogData","console","entry","stack","Error","saveLogs","notifyError","Element","tagName","id","className","textContent","substring","html","outerHTML","Array","isArray","map","item","formatted","value","Object","entries","logs","chrome","storage","local","push","MAX_LOGS","splice","thirtyDaysAgo","setDate","getDate","filteredLogs","filter","notifications","create","type","iconUrl","title","priority","getLogs","Map","logger","constructor","detectAssignments","plannerItems","missingSubmissions","dashboardItems","Promise","all","fetchPlannerItems","fetchMissingSubmissions","parseDashboardCards","assignment","isValidAssignment","response","fetch","headers","credentials","ok","status","json","convertPlannerItem","submission","convertMissingSubmission","cards","assignments","card","processed","convertDashboardAssignment","plannable","plannable_type","determineAssignmentType","dueDate","plannable_date","plannable_id","toString","name","course","context_name","courseId","course_id","points","points_possible","maxPoints","completed","planner_override","marked_complete","priorityScore","url","html_url","details","submissionType","submission_types","isCompleted","isLocked","locked_for_user","description","due_at","shortName","has_submitted_submissions","toLowerCase","PRIORITY_WEIGHTS","GRADE_IMPACT","COURSE_GRADE","DUE_DATE","calculatePriority","metrics","daysUntilDue","calculateDaysUntilDue","gradeImpact","calculateGradeImpact","courseGradeImpact","calculateCourseGradeImpact","typeWeight","getTypeWeight","components","gradeComponent","courseComponent","dateComponent","calculateDueDatePriority","basePriority","Math","min","max","now","diffTime","getTime","ceil","courseGrade","setPriorityWeights","weights","totalWeight","abs","assign","BackgroundService","gradeData","dashboardData","lastSyncTime","settings","priorityWeights","typeWeights","quiz","discussion","announcement","displayOptions","showCourseNames","showGradeImpact","showPriorityScores","highlightOverdue","refreshInterval","debugSettings","enabled","logLevel","showDateDebug","showAssignmentDebug","showPriorityDebug","icalUrl","detector","BackgroundAssignmentDetector","priorityCalculator","BackgroundPriorityCalculator","initialize","setupAutoRefresh","sync","runtime","onMessage","addListener","sender","sendResponse","handleMessage","startPeriodicSync","handleSettingsUpdate","success","getAssignments","updateAssignmentCompletion","assignmentId","refreshAssignments","handleGradeData","handleDashboardData","newSettings","updatePromises","tabs","query","tab","sendMessage","catch","performSync","newAssignments","forEach","sort","a","b","saveAssignments","notifyPopups","count","types","getAssignmentTypeCounts","find","lastUpdated","alarms","periodInMinutes","onAlarm","async","alarm","reduce","counts","courseName","courseData","mergeDashboardData","dashboardAssignment","findDashboardAssignment","values","some","newAssignment","syncIntervalId","window","clearInterval","undefined","retryTimeoutId","clearTimeout","intervalId","setInterval","SYNC_INTERVAL","timeoutId","setTimeout","RETRY_INTERVAL","then","commands","onCommand","command","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__"],"sourceRoot":""}