{"version":3,"file":"background/index.js","mappings":"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","sources":["webpack://canvaspal/./src/utils/logger.ts","webpack://canvaspal/./src/utils/backgroundAssignmentDetector.ts","webpack://canvaspal/./src/utils/backgroundPriorityCalculator.ts","webpack://canvaspal/./src/background/index.ts","webpack://canvaspal/webpack/bootstrap","webpack://canvaspal/webpack/startup"],"sourcesContent":["export enum LogLevel {\n    DEBUG = 0,\n    INFO = 1,\n    WARN = 2,\n    ERROR = 3\n}\n\ninterface LogEntry {\n    timestamp: string;\n    level: LogLevel;\n    message: string;\n    data?: any;\n    stack?: string;\n}\n\nexport class Logger {\n    private static readonly MAX_LOGS = 1000;\n    private static instances: Map<string, Logger> = new Map();\n    private context: string;\n    private currentLevel: LogLevel;\n\n    public constructor(context: string, level: LogLevel = LogLevel.INFO) {\n        this.context = context;\n        this.currentLevel = level;\n        this.cleanOldLogs();\n    }\n\n    public static getInstance(context: string, level: LogLevel = LogLevel.INFO): Logger {\n        const key = `${context}-${level}`;\n        if (!this.instances.has(key)) {\n            this.instances.set(key, new Logger(context, level));\n        }\n        return this.instances.get(key)!;\n    }\n\n    setLevel(level: LogLevel): void {\n        this.currentLevel = level;\n    }\n\n    debug(message: string, data?: any): void {\n        this.log(LogLevel.DEBUG, message, data);\n    }\n\n    info(message: string, data?: any): void {\n        this.log(LogLevel.INFO, message, data);\n    }\n\n    warn(message: string, data?: any): void {\n        this.log(LogLevel.WARN, message, data);\n    }\n\n    error(message: string, data?: any): void {\n        this.log(LogLevel.ERROR, message, data);\n    }\n\n    public async log(level: LogLevel, message: string, ...args: any[]): Promise<void> {\n        if (level >= this.currentLevel) {\n            const timestamp = new Date().toISOString();\n            const prefix = this.getLogPrefix(level);\n            const formattedMessage = `[${timestamp}] ${prefix} [${this.context}] ${message}`;\n\n            if (args.length) {\n                const formattedData = this.formatLogData(args);\n                console.log(formattedMessage, formattedData);\n            } else {\n                console.log(formattedMessage);\n            }\n\n            const entry: LogEntry = {\n                timestamp,\n                level,\n                message,\n                data: args,\n                stack: Error().stack\n            };\n\n            this.saveLogs(entry);\n\n            if (level === LogLevel.ERROR) {\n                this.notifyError(entry);\n            }\n        }\n    }\n\n    private getLogPrefix(level: LogLevel): string {\n        switch (level) {\n            case LogLevel.DEBUG:\n                return 'ðŸ” DEBUG:';\n            case LogLevel.INFO:\n                return 'ðŸ“¢ INFO:';\n            case LogLevel.WARN:\n                return 'âš ï¸ WARN:';\n            case LogLevel.ERROR:\n                return 'âŒ ERROR:';\n            default:\n                return 'ðŸ“¢';\n        }\n    }\n\n    private formatLogData(data: any): any {\n        try {\n            if (Array.isArray(data)) {\n                return data.map(item => this.formatLogData(item));\n            }\n\n            if (data && typeof data === 'object') {\n                // Check if it's an Error object\n                if (data instanceof Error) {\n                    return {\n                        name: data.name,\n                        message: data.message,\n                        stack: data.stack\n                    };\n                }\n\n                // Handle regular objects\n                const formatted: Record<string, any> = {};\n                for (const [key, value] of Object.entries(data)) {\n                    formatted[key] = this.formatLogData(value);\n                }\n                return formatted;\n            }\n\n            return data;\n        } catch (error) {\n            return '[Error formatting log data]';\n        }\n    }\n\n    private async saveLogs(entry: LogEntry): Promise<void> {\n        const { logs = [] } = await chrome.storage.local.get('logs');\n        logs.push(entry);\n\n        if (logs.length > Logger.MAX_LOGS) {\n            logs.splice(0, logs.length - Logger.MAX_LOGS);\n        }\n\n        await chrome.storage.local.set({ logs });\n    }\n\n    private async cleanOldLogs(): Promise<void> {\n        const { logs = [] } = await chrome.storage.local.get('logs');\n        const thirtyDaysAgo = new Date();\n        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n        const filteredLogs = logs.filter((log: LogEntry) => \n            new Date(log.timestamp) > thirtyDaysAgo\n        );\n\n        await chrome.storage.local.set({ logs: filteredLogs });\n    }\n\n    private notifyError(entry: LogEntry): void {\n        chrome.notifications.create({\n            type: 'basic',\n            iconUrl: '/dist/icons/icon128.png',\n            title: 'CanvasPal Error',\n            message: entry.message,\n            priority: 2\n        });\n    }\n\n    async getLogs(level?: LogLevel): Promise<LogEntry[]> {\n        const { logs = [] } = await chrome.storage.local.get('logs');\n        return level ? logs.filter((log: LogEntry) => log.level === level) : logs;\n    }\n}\n\nexport const logger = Logger.getInstance('default');\n","import { Assignment, AssignmentType } from '../types/models';\nimport { Logger } from './logger';\n\nexport class BackgroundAssignmentDetector {\n    private logger: Logger;\n\n    constructor() {\n        this.logger = new Logger('BackgroundAssignmentDetector');\n    }\n\n    public async detectAssignments(): Promise<Assignment[]> {\n        try {\n            // Monitor API fetches in parallel\n            const [plannerItems, missingSubmissions, dashboardItems] = await Promise.all([\n                this.fetchPlannerItems(),\n                this.fetchMissingSubmissions(),\n                this.parseDashboardCards()\n            ]);\n\n            const allAssignments = [...plannerItems, ...missingSubmissions, ...dashboardItems]\n                .filter(assignment => this.isValidAssignment(assignment));\n\n            return allAssignments;\n        } catch (error) {\n            this.logger.error('Error detecting assignments:', error);\n            return [];\n        }\n    }\n\n    private async fetchFromContentScript(url: string, options: RequestInit = {}): Promise<any> {\n        const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n        if (!tabs[0]?.id) {\n            throw new Error('No active tab found');\n        }\n\n        const response = await chrome.tabs.sendMessage(tabs[0].id, {\n            type: 'FETCH_REQUEST',\n            url,\n            options: {\n                ...options,\n                credentials: 'same-origin',\n                headers: {\n                    'Accept': 'application/json',\n                    'X-Requested-With': 'XMLHttpRequest',\n                    ...options.headers\n                }\n            }\n        });\n\n        if (!response.success) {\n            throw new Error(response.error || 'Failed to fetch data');\n        }\n\n        return response.data;\n    }\n\n    private async fetchPlannerItems(): Promise<Assignment[]> {\n        try {\n            const items = await this.fetchFromContentScript('/api/v1/planner/items?per_page=50');\n            return items.map((item: any) => this.convertPlannerItem(item))\n                .filter((item: Assignment | null): item is Assignment => item !== null);\n        } catch (error) {\n            this.logger.error('Error fetching planner items:', error);\n            return [];\n        }\n    }\n\n    private async fetchMissingSubmissions(): Promise<Assignment[]> {\n        try {\n            const submissions = await this.fetchFromContentScript('/api/v1/users/self/missing_submissions?include[]=planner_overrides');\n            return submissions.map((submission: any) => this.convertMissingSubmission(submission))\n                .filter((item: Assignment | null): item is Assignment => item !== null);\n        } catch (error) {\n            this.logger.error('Error fetching missing submissions:', error);\n            return [];\n        }\n    }\n\n    private async parseDashboardCards(): Promise<Assignment[]> {\n        try {\n            const cards = await this.fetchFromContentScript('/api/v1/dashboard/dashboard_cards');\n            const assignments: Assignment[] = [];\n\n            for (const card of cards) {\n                if (card.assignments) {\n                    const processed = card.assignments\n                        .map((assignment: any) => this.convertDashboardAssignment(assignment, card))\n                        .filter((item: Assignment | null): item is Assignment => item !== null);\n                    assignments.push(...processed);\n                }\n            }\n\n            return assignments;\n        } catch (error) {\n            this.logger.error('Error parsing dashboard cards:', error);\n            return [];\n        }\n    }\n\n    private convertPlannerItem(item: any): Assignment | null {\n        if (!item.plannable || !item.plannable_type) return null;\n\n        const type = this.determineAssignmentType(item.plannable_type);\n        const dueDate = item.plannable_date ? new Date(item.plannable_date) : null;\n\n        if (!type || !dueDate) return null;\n\n        return {\n            id: item.plannable_id.toString(),\n            title: item.plannable?.title || item.plannable?.name || '',\n            dueDate,\n            course: item.context_name || '',\n            courseId: item.course_id?.toString(),\n            type,\n            points: item.plannable?.points_possible,\n            maxPoints: item.plannable?.points_possible,\n            completed: !!item.planner_override?.marked_complete,\n            priorityScore: 0,\n            url: item.html_url,\n            details: {\n                submissionType: item.plannable?.submission_types,\n                isCompleted: !!item.planner_override?.marked_complete,\n                isLocked: !!item.plannable?.locked_for_user,\n                description: item.plannable?.description\n            }\n        };\n    }\n\n    private convertMissingSubmission(submission: any): Assignment | null {\n        if (!submission.due_at) return null;\n\n        return {\n            id: submission.id.toString(),\n            title: submission.name || submission.assignment?.name || '',\n            dueDate: new Date(submission.due_at),\n            course: submission.course?.name || '',\n            courseId: submission.course_id?.toString(),\n            type: 'assignment',\n            points: submission.points_possible,\n            maxPoints: submission.points_possible,\n            completed: false,\n            priorityScore: 0,\n            url: submission.html_url,\n            details: {\n                isCompleted: false,\n                isLocked: false\n            }\n        };\n    }\n\n    private convertDashboardAssignment(assignment: any, card: any): Assignment | null {\n        if (!assignment.due_at) return null;\n\n        const type = this.determineAssignmentType(assignment.type);\n        \n        return {\n            id: assignment.id.toString(),\n            title: assignment.name || '',\n            dueDate: new Date(assignment.due_at),\n            course: card.shortName || '',\n            courseId: card.id?.toString(),\n            type,\n            points: assignment.points_possible,\n            maxPoints: assignment.points_possible,\n            completed: !!assignment.has_submitted_submissions,\n            priorityScore: 0,\n            url: assignment.html_url,\n            details: {\n                submissionType: assignment.submission_types,\n                isCompleted: !!assignment.has_submitted_submissions,\n                isLocked: !!assignment.locked_for_user,\n                description: assignment.description\n            }\n        };\n    }\n\n    private determineAssignmentType(type: string): AssignmentType {\n        switch (type.toLowerCase()) {\n            case 'quiz':\n            case 'quizzes/quiz':\n                return 'quiz';\n            case 'discussion_topic':\n                return 'discussion';\n            case 'announcement':\n                return 'announcement';\n            default:\n                return 'assignment';\n        }\n    }\n\n    private isValidAssignment(assignment: Assignment | null): assignment is Assignment {\n        return assignment !== null &&\n            !!assignment.title &&\n            !!assignment.dueDate &&\n            !!assignment.course;\n    }\n}","import { Assignment, PriorityWeights } from '../types/models';\nimport { Logger } from './logger';\n\nexport class BackgroundPriorityCalculator {\n    private readonly PRIORITY_WEIGHTS: PriorityWeights = {\n        GRADE_IMPACT: 0.4,\n        COURSE_GRADE: 0.3,\n        DUE_DATE: 0.3\n    };\n\n    private logger: Logger;\n\n    constructor() {\n        this.logger = new Logger('BackgroundPriorityCalculator');\n    }\n\n    public calculatePriority(assignment: Assignment): number {\n        try {\n            const metrics = {\n                daysUntilDue: this.calculateDaysUntilDue(assignment.dueDate),\n                gradeImpact: this.calculateGradeImpact(assignment),\n                courseGradeImpact: this.calculateCourseGradeImpact(assignment),\n                typeWeight: this.getTypeWeight(assignment.type)\n            };\n\n            // Calculate individual components\n            const components = {\n                gradeComponent: metrics.gradeImpact * this.PRIORITY_WEIGHTS.GRADE_IMPACT,\n                courseComponent: metrics.courseGradeImpact * this.PRIORITY_WEIGHTS.COURSE_GRADE,\n                dateComponent: this.calculateDueDatePriority(metrics.daysUntilDue) * this.PRIORITY_WEIGHTS.DUE_DATE\n            };\n\n            // Calculate final priority\n            const basePriority = components.gradeComponent + components.courseComponent + components.dateComponent;\n            const finalPriority = Math.min(Math.max(basePriority * metrics.typeWeight, 0), 1);\n\n            return finalPriority;\n        } catch (error) {\n            this.logger.error('Error calculating priority:', error);\n            return 0;\n        }\n    }\n\n    private calculateDaysUntilDue(dueDate: Date): number {\n        const now = new Date();\n        const diffTime = dueDate.getTime() - now.getTime();\n        return Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n    }\n\n    private calculateDueDatePriority(daysUntilDue: number): number {\n        if (daysUntilDue <= 0) return 1; // Overdue assignments get highest priority\n        if (daysUntilDue >= 14) return 0.2; // Far future assignments get low priority\n        return 1 - (daysUntilDue / 14); // Linear decrease in priority over 14 days\n    }\n\n    private calculateGradeImpact(assignment: Assignment): number {\n        if (!assignment.points || !assignment.maxPoints) return 0.5; // Default impact if no points info\n        return Math.min(assignment.points / 100, 1); // Normalize to 0-1 range\n    }\n\n    private calculateCourseGradeImpact(assignment: Assignment): number {\n        if (!assignment.courseGrade) return 0.85; // Default if no course grade available\n        return 1 - assignment.courseGrade; // Lower grades mean higher priority\n    }\n\n    private getTypeWeight(type: Assignment['type']): number {\n        switch (type) {\n            case 'quiz':\n                return 1.2; // Quizzes get 20% boost\n            case 'assignment':\n                return 1.0; // Standard weight\n            case 'discussion':\n                return 0.8; // Discussions slightly lower\n            case 'announcement':\n                return 0.5; // Announcements lowest priority\n            default:\n                return 1.0;\n        }\n    }\n\n    public setPriorityWeights(weights: Partial<PriorityWeights>): void {\n        const totalWeight = (weights.GRADE_IMPACT || this.PRIORITY_WEIGHTS.GRADE_IMPACT) +\n                          (weights.COURSE_GRADE || this.PRIORITY_WEIGHTS.COURSE_GRADE) +\n                          (weights.DUE_DATE || this.PRIORITY_WEIGHTS.DUE_DATE);\n\n        if (Math.abs(totalWeight - 1) > 0.001) {\n            this.logger.warn('Priority weights do not sum to 1. Using default weights.');\n            return;\n        }\n\n        Object.assign(this.PRIORITY_WEIGHTS, weights);\n        this.logger.info('Priority weights updated:', this.PRIORITY_WEIGHTS);\n    }\n}","import type { CalendarEvent, PrioritySettings, GradeData, DashboardData, Assignment } from '../types/models';\nimport { parseICalFeed } from '../utils/calendar';\nimport { calculatePriority } from '../utils/priorities';\nimport { logger, LogLevel, Logger } from '../utils/logger';\nimport { BackgroundAssignmentDetector } from '../utils/backgroundAssignmentDetector';\nimport { BackgroundPriorityCalculator } from '../utils/backgroundPriorityCalculator';\n\nimport { Settings } from '../types/models';\n\ninterface ICalEvent extends CalendarEvent {\n    gradeWeight?: number;\n    pointsPossible?: number;\n    currentScore?: number;\n}\n\nclass BackgroundService {\n    private static readonly SYNC_INTERVAL = 30 * 60 * 1000;\n    private static readonly RETRY_INTERVAL = 5 * 60 * 1000;\n    private gradeData: { [courseId: string]: GradeData } = {};\n    private dashboardData: { [courseId: string]: DashboardData } = {};\n    private lastSyncTime = 0;\n    private syncIntervalId?: number;\n    private retryTimeoutId?: number;\n    private settings: Settings;\n    private assignments: Assignment[] = [];\n    private detector: BackgroundAssignmentDetector;\n    private priorityCalculator: BackgroundPriorityCalculator;\n    private logger: Logger;\n    private contentScriptReady = false;\n\n    constructor() {\n        this.settings = {\n            priorityWeights: {\n                GRADE_IMPACT: 0.4,\n                COURSE_GRADE: 0.3,\n                DUE_DATE: 0.3\n            },\n            typeWeights: {\n                quiz: 1.2,\n                assignment: 1.0,\n                discussion: 0.8,\n                announcement: 0.5\n            },\n            displayOptions: {\n                showCourseNames: true,\n                showGradeImpact: true,\n                showPriorityScores: true,\n                highlightOverdue: true\n            },\n            refreshInterval: 30,\n            debugSettings: {\n                enabled: false,\n                logLevel: 'info',\n                showDateDebug: false,\n                showAssignmentDebug: false,\n                showPriorityDebug: false\n            },\n            icalUrl: ''\n        };\n        this.detector = new BackgroundAssignmentDetector();\n        this.priorityCalculator = new BackgroundPriorityCalculator();\n        this.logger = new Logger('BackgroundService');\n        this.initialize();\n        this.setupAutoRefresh();\n    }\n\n    public async initialize(): Promise<void> {\n        try {\n            // Load settings from sync storage\n            const { settings } = await chrome.storage.sync.get('settings');\n            if (settings) {\n                this.settings = settings;\n            } else {\n                // Initialize default settings if none exist\n                await chrome.storage.sync.set({ settings: this.settings });\n            }\n\n            // Set up message listeners\n            chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n                this.handleMessage(message, sender, sendResponse);\n                return true; // Keep the message channel open for async response\n            });\n\n            this.startPeriodicSync();\n            this.logger.info('Background service initialized');\n        } catch (error) {\n            this.logger.error('Error initializing background service:', error);\n        }\n    }\n\n    private async handleMessage(\n        message: any, \n        sender: chrome.runtime.MessageSender, \n        sendResponse: (response?: any) => void\n    ): Promise<void> {\n        try {\n            switch (message.type) {\n                case 'SETTINGS_UPDATED':\n                    await this.handleSettingsUpdate(message.settings);\n                    sendResponse({ success: true });\n                    break;\n\n                case 'GET_ASSIGNMENTS':\n                    if (!this.contentScriptReady) {\n                        sendResponse({ assignments: [], message: 'Loading assignments...' });\n                        return;\n                    }\n                    const assignments = await this.getAssignments();\n                    sendResponse({ assignments });\n                    break;\n\n                case 'UPDATE_ASSIGNMENT_COMPLETION':\n                    await this.updateAssignmentCompletion(\n                        message.assignmentId,\n                        message.completed\n                    );\n                    sendResponse({ success: true });\n                    break;\n\n                case 'REFRESH_ASSIGNMENTS':\n                    await this.refreshAssignments();\n                    sendResponse({ success: true });\n                    break;\n\n                case 'GRADE_DATA':\n                    this.handleGradeData(message.data);\n                    sendResponse({ success: true });\n                    break;\n\n                case 'DASHBOARD_DATA':\n                    this.handleDashboardData(message.data);\n                    sendResponse({ success: true });\n                    break;\n\n                case 'CONTENT_SCRIPT_READY':\n                    this.logger.info('Content script ready');\n                    this.contentScriptReady = true;\n                    sendResponse({ success: true });\n                    // Wait a bit for the page to fully load before fetching assignments\n                    setTimeout(() => {\n                        void this.refreshAssignments();\n                    }, 1000);\n                    break;\n\n                default:\n                    this.logger.warn('Unknown message type:', message);\n                    sendResponse({ error: 'Unknown message type' });\n            }\n        } catch (error) {\n            this.logger.error('Error handling message:', error);\n            sendResponse({ error: 'Internal error' });\n        }\n    }\n\n    private async handleSettingsUpdate(newSettings: Settings): Promise<void> {\n        this.settings = newSettings;\n        \n        // Save to storage\n        await chrome.storage.sync.set({ settings: newSettings });\n\n        // Notify all Canvas tabs\n        const tabs = await chrome.tabs.query({\n            url: [\n                \"*://*.instructure.com/*\",\n                \"*://*.canvas.com/*\"\n            ]\n        });\n\n        // Send update to each tab\n        const updatePromises = tabs.map(tab => {\n            if (tab.id) {\n                return chrome.tabs.sendMessage(tab.id, {\n                    type: 'SETTINGS_UPDATED',\n                    settings: newSettings\n                }).catch(error => {\n                    // Log but don't fail if a tab doesn't have our content script\n                    this.logger.debug(`Could not update tab ${tab.id}:`, error);\n                });\n            }\n        });\n\n        await Promise.all(updatePromises);\n        this.logger.info('Settings updated and propagated to all tabs');\n\n        // Trigger a sync with new settings\n        await this.performSync();\n    }\n\n    private async getAssignments(): Promise<Assignment[]> {\n        if (this.assignments.length === 0) {\n            await this.refreshAssignments();\n        }\n        return this.assignments;\n    }\n\n    public async refreshAssignments(): Promise<void> {\n        if (!this.contentScriptReady) {\n            this.logger.warn('Content script not ready, waiting for initialization');\n            return;\n        }\n\n        try {\n            // Find active Canvas tab\n            const tabs = await chrome.tabs.query({\n                active: true,\n                url: [\"*://*.instructure.com/*\", \"*://*.canvas.com/*\"]\n            });\n\n            if (!tabs.length) {\n                this.logger.warn('No active Canvas tab found');\n                this.assignments = [];\n                await this.saveAssignments();\n                this.notifyPopups();\n                return;\n            }\n\n            // Get assignments from detector\n            const newAssignments = await this.detector.detectAssignments();\n\n            // Calculate priorities for each assignment\n            newAssignments.forEach((assignment: Assignment) => {\n                assignment.priorityScore = this.priorityCalculator.calculatePriority(assignment);\n            });\n\n            // Sort by priority\n            newAssignments.sort((a: Assignment, b: Assignment) => b.priorityScore - a.priorityScore);\n\n            // Update stored assignments\n            this.assignments = newAssignments;\n\n            // Save to storage and notify popups\n            await this.saveAssignments();\n            this.notifyPopups();\n\n            this.logger.info('Assignments refreshed:', {\n                count: newAssignments.length,\n                types: this.getAssignmentTypeCounts(newAssignments)\n            });\n        } catch (error) {\n            this.logger.error('Error refreshing assignments:', error);\n            this.assignments = [];\n            await this.saveAssignments();\n            this.notifyPopups();\n            throw error;\n        }\n    }\n\n    public async updateAssignmentCompletion(\n        assignmentId: string,\n        completed: boolean\n    ): Promise<void> {\n        const assignment = this.assignments.find(a => a.id === assignmentId);\n        if (assignment) {\n            assignment.completed = completed;\n            await this.saveAssignments();\n            this.notifyPopups();\n        }\n    }\n\n    private async saveAssignments(): Promise<void> {\n        try {\n            await chrome.storage.local.set({ \n                assignments: this.assignments,\n                lastUpdated: new Date().toISOString()\n            });\n        } catch (error) {\n            this.logger.error('Error saving assignments:', error);\n            throw error;\n        }\n    }\n\n    private notifyPopups(): void {\n        const message = {\n            type: 'ASSIGNMENTS_UPDATED',\n            assignments: this.assignments,\n            status: this.getAssignmentStatus()\n        };\n\n        // Send to popups\n        chrome.runtime.sendMessage(message).catch(error => {\n            // Ignore errors - popups might not be open\n            this.logger.debug('No popups to notify:', error);\n        });\n\n        // Send to content scripts\n        chrome.tabs.query({\n            url: [\"*://*.instructure.com/*\", \"*://*.canvas.com/*\"]\n        }).then(tabs => {\n            tabs.forEach(tab => {\n                if (tab.id) {\n                    chrome.tabs.sendMessage(tab.id, message).catch(error => {\n                        this.logger.debug(`Could not notify tab ${tab.id}:`, error);\n                    });\n                }\n            });\n        });\n    }\n\n    private getAssignmentStatus(): string {\n        if (!this.contentScriptReady) {\n            return 'Loading assignments...';\n        }\n        if (this.assignments.length === 0) {\n            return 'No assignments found';\n        }\n        return `Found ${this.assignments.length} assignments`;\n    }\n\n    private setupAutoRefresh(): void {\n        // Refresh every 30 minutes\n        chrome.alarms.create('refreshAssignments', { periodInMinutes: 30 });\n        \n        chrome.alarms.onAlarm.addListener(async (alarm) => {\n            if (alarm.name === 'refreshAssignments') {\n                await this.refreshAssignments();\n            }\n        });\n    }\n\n    private getAssignmentTypeCounts(assignments: Assignment[]): Record<string, number> {\n        return assignments.reduce((counts, assignment) => {\n            counts[assignment.type] = (counts[assignment.type] || 0) + 1;\n            return counts;\n        }, {} as Record<string, number>);\n    }\n\n    private handleGradeData(data: GradeData): void {\n        try {\n            this.logger.info('Received grade data:', data);\n            this.gradeData[data.courseName] = data;\n            chrome.storage.local.set({ \n                [`grades_${data.courseName}`]: data,\n                lastUpdated: new Date().toISOString()\n            });\n        } catch (error) {\n            this.logger.error('Error handling grade data:', error);\n        }\n    }\n\n    private handleDashboardData(data: DashboardData[]): void {\n        try {\n            this.logger.info('Received dashboard data:', data);\n            data.forEach(courseData => {\n                this.dashboardData[courseData.courseName] = courseData;\n                chrome.storage.local.set({\n                    [`dashboard_${courseData.courseName}`]: courseData,\n                    lastUpdated: new Date().toISOString()\n                });\n            });\n            \n            // Update assignments with dashboard data\n            this.mergeDashboardData();\n        } catch (error) {\n            this.logger.error('Error handling dashboard data:', error);\n        }\n    }\n\n    private mergeDashboardData(): void {\n        // Update existing assignments with dashboard information\n        this.assignments = this.assignments.map(assignment => {\n            const dashboardAssignment = this.findDashboardAssignment(assignment);\n            if (dashboardAssignment) {\n                return {\n                    ...assignment,\n                    dueDate: new Date(dashboardAssignment.dueDate),\n                    type: dashboardAssignment.type || assignment.type\n                };\n            }\n            return assignment;\n        });\n\n        // Add new assignments from dashboard that don't exist\n        Object.values(this.dashboardData).forEach(courseData => {\n            courseData.assignments.forEach(dashboardAssignment => {\n                const exists = this.assignments.some(a => \n                    a.title.toLowerCase() === dashboardAssignment.name.toLowerCase() &&\n                    a.course === courseData.courseName\n                );\n\n                if (!exists) {\n                    const newAssignment: Assignment = {\n                        id: `${courseData.courseName}_${dashboardAssignment.name}`,\n                        title: dashboardAssignment.name,\n                        dueDate: new Date(dashboardAssignment.dueDate),\n                        course: courseData.courseName,\n                        courseId: courseData.courseName,\n                        type: dashboardAssignment.type,\n                        points: 0,\n                        maxPoints: 0,\n                        priorityScore: 0,\n                        completed: false,\n                        url: '',\n                        details: {\n                            isCompleted: false,\n                            isLocked: false\n                        }\n                    };\n                    this.assignments.push(newAssignment);\n                }\n            });\n        });\n\n        // Recalculate priorities and sort\n        this.assignments.forEach(assignment => {\n            assignment.priorityScore = this.priorityCalculator.calculatePriority(assignment);\n        });\n        this.assignments.sort((a, b) => b.priorityScore - a.priorityScore);\n\n        // Save updated assignments\n        void this.saveAssignments();\n    }\n\n    private findDashboardAssignment(assignment: Assignment): DashboardData['assignments'][0] | undefined {\n        const courseData = this.dashboardData[assignment.course];\n        if (!courseData) return undefined;\n\n        return courseData.assignments.find(a => \n            a.name.toLowerCase() === assignment.title.toLowerCase()\n        );\n    }\n\n    private startPeriodicSync(): void {\n        if (this.syncIntervalId) {\n            window.clearInterval(this.syncIntervalId);\n            this.syncIntervalId = undefined;\n        }\n        if (this.retryTimeoutId) {\n            window.clearTimeout(this.retryTimeoutId);\n            this.retryTimeoutId = undefined;\n        }\n\n        void this.performSync();\n        const intervalId = window.setInterval(\n            () => { void this.performSync(); },\n            BackgroundService.SYNC_INTERVAL\n        );\n        this.syncIntervalId = intervalId;\n    }\n\n    public async performSync(): Promise<void> {\n        try {\n            const now = Date.now();\n            if (now - this.lastSyncTime < 60000) {\n                return;\n            }\n\n            await this.refreshAssignments();\n            this.lastSyncTime = now;\n            await this.logger.info('Sync completed successfully');\n            chrome.runtime.sendMessage({ type: \"syncComplete\", timestamp: now });\n        } catch (error) {\n            await this.logger.error('Sync failed', error);\n            console.error(\"Sync failed:\", error);\n            const timeoutId = window.setTimeout(() => {\n                void this.performSync();\n            }, BackgroundService.RETRY_INTERVAL);\n            this.retryTimeoutId = timeoutId;\n            chrome.runtime.sendMessage({ \n                type: \"syncError\", \n                error: error instanceof Error ? error.message : \"Unknown error\"\n            });\n        }\n    }\n}\n\n// Create and export a singleton instance\nexport const backgroundService = new BackgroundService();\n\n// Initialize background service and set up listeners\nbackgroundService.initialize().then(() => {\n    // Set up alarm listener for periodic sync\n    chrome.alarms.create('sync', { periodInMinutes: 30 });\n    chrome.alarms.onAlarm.addListener((alarm) => {\n        if (alarm.name === 'sync') {\n            void backgroundService.performSync();\n        }\n    });\n\n    // Add keyboard command listener\n    chrome.commands.onCommand.addListener((command) => {\n        if (command === 'refresh-assignments') {\n            void backgroundService.performSync();\n        }\n    });\n});\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(922);\n"],"names":["LogLevel","Logger","context","level","INFO","this","currentLevel","cleanOldLogs","getInstance","key","instances","has","set","get","setLevel","debug","message","data","log","DEBUG","info","warn","WARN","error","ERROR","args","timestamp","Date","toISOString","formattedMessage","getLogPrefix","length","formattedData","formatLogData","console","entry","stack","Error","saveLogs","notifyError","Array","isArray","map","item","name","formatted","value","Object","entries","logs","chrome","storage","local","push","MAX_LOGS","splice","thirtyDaysAgo","setDate","getDate","filteredLogs","filter","notifications","create","type","iconUrl","title","priority","getLogs","Map","logger","constructor","detectAssignments","plannerItems","missingSubmissions","dashboardItems","Promise","all","fetchPlannerItems","fetchMissingSubmissions","parseDashboardCards","assignment","isValidAssignment","fetchFromContentScript","url","options","tabs","query","active","currentWindow","id","response","sendMessage","credentials","headers","success","convertPlannerItem","submission","convertMissingSubmission","cards","assignments","card","processed","convertDashboardAssignment","plannable","plannable_type","determineAssignmentType","dueDate","plannable_date","plannable_id","toString","course","context_name","courseId","course_id","points","points_possible","maxPoints","completed","planner_override","marked_complete","priorityScore","html_url","details","submissionType","submission_types","isCompleted","isLocked","locked_for_user","description","due_at","shortName","has_submitted_submissions","toLowerCase","PRIORITY_WEIGHTS","GRADE_IMPACT","COURSE_GRADE","DUE_DATE","calculatePriority","metrics","daysUntilDue","calculateDaysUntilDue","gradeImpact","calculateGradeImpact","courseGradeImpact","calculateCourseGradeImpact","typeWeight","getTypeWeight","components","gradeComponent","courseComponent","dateComponent","calculateDueDatePriority","basePriority","Math","min","max","now","diffTime","getTime","ceil","courseGrade","setPriorityWeights","weights","totalWeight","abs","assign","BackgroundService","gradeData","dashboardData","lastSyncTime","contentScriptReady","settings","priorityWeights","typeWeights","quiz","discussion","announcement","displayOptions","showCourseNames","showGradeImpact","showPriorityScores","highlightOverdue","refreshInterval","debugSettings","enabled","logLevel","showDateDebug","showAssignmentDebug","showPriorityDebug","icalUrl","detector","BackgroundAssignmentDetector","priorityCalculator","BackgroundPriorityCalculator","initialize","setupAutoRefresh","sync","runtime","onMessage","addListener","sender","sendResponse","handleMessage","startPeriodicSync","handleSettingsUpdate","getAssignments","updateAssignmentCompletion","assignmentId","refreshAssignments","handleGradeData","handleDashboardData","setTimeout","newSettings","updatePromises","tab","catch","performSync","saveAssignments","notifyPopups","newAssignments","forEach","sort","a","b","count","types","getAssignmentTypeCounts","find","lastUpdated","status","getAssignmentStatus","then","alarms","periodInMinutes","onAlarm","async","alarm","reduce","counts","courseName","courseData","mergeDashboardData","dashboardAssignment","findDashboardAssignment","values","some","newAssignment","syncIntervalId","window","clearInterval","undefined","retryTimeoutId","clearTimeout","intervalId","setInterval","SYNC_INTERVAL","timeoutId","RETRY_INTERVAL","commands","onCommand","command","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__"],"sourceRoot":""}